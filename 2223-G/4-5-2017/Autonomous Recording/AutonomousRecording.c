#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           RightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port10,          LeftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, dgtl1)
#pragma config(DatalogSeries, 0, "leftEncoder", Sensors, Sensor, dgtl1, 10)
#pragma config(DatalogSeries, 1, "rightEncoder", Sensors, Sensor, dgtl3, 10)
#pragma config(DatalogSeries, 2, "LeftMotor", Motors, MotorPower, port10, 10)
#pragma config(DatalogSeries, 3, "RightMotor", Motors, MotorPower, port1, 10)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

short baseLeft[1750], baseRight[1750], encoderLeft[1750], encoderRight[1750];
int threshold = 20, buttonToggleState = 0, buttonPressed = 0;

void toggleButton();
void recordValues(int currentCycle);
void executeAutonomous();

task main(){
	datalogClear();
	for(int c = 0; true;){

		//Toggle button
		toggleButton();

		//Control the base taking into account the threshold

		motor[LeftMotor] = (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] - vexRT[Ch1]) : 0;
		motor[RightMotor] = (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] + vexRT[Ch1]) : 0;

		//Record Values only if button 8 right was pressed
		if (buttonToggleState){
			recordValues(c);
			c++;
		}

		//Do the autonomous after pressing button 7 left
		if(vexRT[Btn7L] == 1){
			executeAutonomous();
		}
		//End the loop by waiting 20 milliseconds
		wait1Msec(10);
	}
}

void toggleButton(){
	if( vexRT[Btn8R]){
		if(!buttonPressed){
			buttonToggleState = 1 - buttonToggleState;
			buttonPressed = 1;
		}
	}
	else buttonPressed = 0;
}

void recordValues(int currentCycle){
	//If the base left and right are running at a similar power (really close values) then make them go at the same speed
	//by storing the same value on the left and on the right base
	/*if((vexRT[Ch2] - vexRT[Ch1]) >= (vexRT[Ch2] + vexRT[Ch1])-threshold && (vexRT[Ch2] - vexRT[Ch1]) <= (vexRT[Ch2] + vexRT[Ch1])+threshold){
		baseLeft[currentCycle] =  (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] - vexRT[Ch1]) : 0;
		baseRight[currentCycle] = baseLeft[currentCycle];
		encoderLeft[currentCycle] = SensorValue[leftEncoder];	encoderRight[currentCycle] = encoderLeft[currentCycle];	//Read encoder values
		SensorValue[rightEncoder] = SensorValue[leftEncoder];
	}
	//If base point turn left and running at similar power, then make both sides go at same, opposite speed
	else if(vexRT[Ch2] - vexRT[Ch1]<0 && abs(vexRT[Ch2] - vexRT[Ch1]) >= (vexRT[Ch2] + vexRT[Ch1])-threshold && abs(vexRT[Ch2] - vexRT[Ch1]) <= (vexRT[Ch2] + vexRT[Ch1])+threshold){
		baseLeft[currentCycle] =  (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] - vexRT[Ch1]) : 0;
		baseRight[currentCycle] = abs(baseLeft[currentCycle]);
		encoderLeft[currentCycle] = SensorValue[leftEncoder];	encoderRight[currentCycle] = encoderLeft[currentCycle];	//Read encoder values
		SensorValue[rightEncoder] = SensorValue[leftEncoder];
	}
	//If base point turn right and running at similar power, then make both sides go at same, opposite speed
	else if(vexRT[Ch2] - vexRT[Ch1]>0 && (vexRT[Ch2] - vexRT[Ch1]) >= abs(vexRT[Ch2] + vexRT[Ch1])-threshold && (vexRT[Ch2] - vexRT[Ch1]) <= abs(vexRT[Ch2] + vexRT[Ch1])+threshold){
		baseRight[currentCycle] =  (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] + vexRT[Ch1]) : 0;
		baseLeft[currentCycle] = abs(baseRight[currentCycle]);
		encoderRight[currentCycle] = SensorValue[rightEncoder];	encoderLeft[currentCycle] = encoderRight[currentCycle];	//Read encoder values
		SensorValue[leftEncoder] = SensorValue[rightEncoder];
	}
	//If the base's motors are running at different power then store the values as they are
	else{*/
		baseLeft[currentCycle] =  (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] - vexRT[Ch1]) : 0;
		baseRight[currentCycle] = (vexRT[Ch2]>threshold  || vexRT[Ch2]< -(threshold) || vexRT[Ch1]>threshold || vexRT[Ch1]< -(threshold)) ? (vexRT[Ch2] + vexRT[Ch1]) : 0;
		encoderLeft[currentCycle] = SensorValue[leftEncoder];	encoderRight[currentCycle] = SensorValue[rightEncoder];	//Read encoder values
	//}
}

void executeAutonomous(){
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	for(int d = 0; d < sizeof(baseLeft)/sizeof(short); d++){
		for(int e = 0; e<10; e++){
			motor[LeftMotor] = SensorValue[leftEncoder] != encoderLeft[d]	? baseLeft[d]* 1.1:	-(baseLeft[d]);
			motor[RightMotor] = SensorValue[rightEncoder] != encoderRight[d]	? baseRight[d]* 1.1: -(baseLeft[d]);

			//Record data
			datalogDataGroupStart();
			datalogAddValue(1, SensorValue[leftEncoder]);
			datalogAddValue(2,SensorValue[rightEncoder]);
			datalogDataGroupEnd();

			wait1Msec(1);
		}


	}
}
