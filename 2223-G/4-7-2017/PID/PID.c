#pragma config(Sensor, dgtl1,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderRight,   sensorQuadEncoder)
#pragma config(Motor,  port1,           motorRight,    tmotorVex393_HBridge, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port10,          motorLeft,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//6, 8, 2, 4

void move(string *direction, byte speed, int pulses);

//PID constants
#define Kp 1
#define Ki 0.025
#define Kd 3

//Integrl limir
#define integralLimit 25


task main(){
	move("forward", 127, 360);
	move("backwards", 127, 720);
	move("pointTurnLeft", 127, 180);
	move("pointTurnRight", 127, 180);
	move("sTL", 127, 180);
	move("sTR", 75, 180);
}

int errorLeft = 0, lastErrorLeft = 0, integralLeft = 0, derivativeLeft = 0, outputLeft = 0;
int errorRight = 0, lastErrorRight = 0, integralRight = 0, derivativeRight = 0, outputRight = 0;

void move(string *direction, byte speed, int pulses){

	//Preset all values to 0
	errorLeft = 0; lastErrorLeft = 0; integralLeft = 0; derivativeLeft = 0; outputLeft = 0;
	errorRight = 0; lastErrorRight = 0; integralRight = 0; derivativeRight = 0; outputRight = 0;
	SensorValue[encoderLeft] = 0;	SensorValue[encoderRight] = 0;

	//While distance not reached
	while(abs(SensorValue[encoderLeft]) < pulses || abs(SensorValue[encoderRight]) < pulses){

		//Calculate error
		errorLeft = pulses - abs(SensorValue[encoderLeft]);
		errorRight = pulses - abs(SensorValue[encoderRight]);

		//Calculate the integral only if it is less than its limit and 9/10 of the total distance travelled
		integralLeft += (integralLeft < integralLimit && integralLeft > -integralLimit && abs(SensorValue[encoderLeft]) < pulses / 10) ? errorLeft : 0;
		integralRight += (integralRight < integralLimit && integralLeft > -integralLimit  && abs(SensorValue[encoderRight]) < pulses / 10) ? errorRight : 0;

		//Calculate derivative
		derivativeLeft = errorLeft - lastErrorLeft;	derivativeRight = errorRight - lastErrorRight;

		//Retrieve  the last error
		lastErrorLeft = errorLeft;	lastErrorRight = errorRight;

		//Calculate the ouput using the PID constants and the calculated error, integral and derivative
		outputLeft = (Kp * errorLeft) + (Ki * integralLeft) + (Kd * derivativeLeft);
		outputRight = (Kp * errorRight) + (Ki * integralRight) + (Kd * derivativeRight);

		//Make sure the output speed is less than the max speed
		if(outputLeft > speed) outputLeft = speed;
		else if (outputLeft < -speed) outputLeft = -speed;
		if(outputRight > speed) outputRight = speed;
		else if (outputRight < -speed) outputRight = -speed;

		//Move the base based on the direction desired
		if( *direction ==  "forward" || *direction ==  "front" || *direction ==  "f"){
			motor[motorLeft] = outputLeft / ((abs(SensorValue[encoderLeft]) - abs(SensorValue[encoderRight])) * 0.01 + 1);
			motor[motorRight] = outputRight / ((abs(SensorValue[encoderRight]) - abs(SensorValue[encoderLeft])) * 0.01 + 1);
		}

		else if (*direction ==  "backward" || *direction ==  "backwards" || *direction == "bacck" || *direction ==  "b"){
			motor[motorLeft] = -(outputLeft / ((abs(SensorValue[encoderLeft]) - abs(SensorValue[encoderRight])) * 0.01 + 1));
			motor[motorRight] = -(outputRight / ((abs(SensorValue[encoderRight]) - abs(SensorValue[encoderLeft])) * 0.01 + 1));
		}

		else if (*direction ==  "left" || *direction ==  "rotateLeft" || *direction ==  "pointTurnLeft" ||
			*direction ==  "pointLeft" || *direction ==  "pLeft" || *direction ==  "pointL" || *direction ==  "pL"){
			motor[motorLeft] = -(outputLeft / ((abs(SensorValue[encoderLeft]) - abs(SensorValue[encoderRight])) * 0.01 + 1));
			motor[motorRight] = outputRight / ((abs(SensorValue[encoderRight]) - abs(SensorValue[encoderLeft])) * 0.01 + 1);
		}

		else if (*direction ==  "right" || *direction ==  "rotateRight" || *direction ==  "pointTurnRight" ||
			*direction ==  "pointRight" || *direction ==  "pRight" || *direction ==  "pointR" || *direction ==  "pR"){
			motor[motorLeft] = outputLeft / ((abs(SensorValue[encoderLeft]) - abs(SensorValue[encoderRight])) * 0.01 + 1);
			motor[motorRight] = -(outputRight / ((abs(SensorValue[encoderRight]) - abs(SensorValue[encoderLeft])) * 0.01 + 1));
		}

		else if (*direction ==  "swingTurnLeft"	|| *direction ==  "sTurnLeft"	|| *direction ==  "sTLeft"	|| *direction ==  "sTL"){
			motor[motorRight] = outputRight / ((abs(SensorValue[encoderRight]) - abs(SensorValue[encoderLeft])) * 0.01 + 1);
		}

		else if(*direction ==  "swingTurnRight"	|| *direction ==  "sTurnRight"	|| *direction ==  "sTRight" || *direction ==  "sTR"){
			motor[motorLeft] = outputLeft / ((abs(SensorValue[encoderLeft]) - abs(SensorValue[encoderRight])) * 0.01 + 1);
		}

		wait1Msec(20);
	}
	wait1Msec(50);
}
